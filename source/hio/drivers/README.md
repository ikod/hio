

#### Таймеры ###

##### Сценарии добавления и удаления таймеров. #####

Исходное состояние.

       
    -----|--------------|---
         t₀             tₓ

а) Добавление нового таймера, с временем срабатывания позднее t₀

                ↓
    -----|--------------|---
         t₀             tₓ

б) Добавление нового таймера, с временем срабатывания до t₀

      ↓
    -----|--------------|---
         t₀             tₓ

в) Удаление или срабатывание таймера t₀

         
    -----❌----|---------|---
         t₀   t₁        tₓ

д) Удаление любого таймера правее t₀

              
    -----|----❌---------|---
         t₀   t₁        tₓ

##### Инварианты: #####
* ядро всегда знает только о самом раннем таймере.
* в обрабочике событий ядра сработавший таймер всегда является самым первым (ранним)
* любая операция по добавлению/модификаций в ядре должна заканчиваться успешно
* в ядро не посылаются таймеры с Δt ≤ 0
##### Добавление таймера #####

Любое добавление требует вставки в список (дерево).

Если передавать в ядро информацию только о самом раннем таймере
случай А не требует обращения к ядру - достаточно добавить
таймер в список в теле eventloop.

В случае Б нужно поменять в ядре таймер на более ранний.

##### Удаление и срабатывание таймера #####

Удаление не самого раннего таймера требует только его удаления из списка.

Удаление и срабатывание самого раннего таймера (а срабатывание обязано быть на самом раннем таймере),
приводит к переустановке таймера в ядре на следующий если он есть.

Если следующего таймера нет - удаляем.

Если следующий просрочен - вставляем с задержкой 0.

##### "опоздавшие" таймеры

Если обработка срабатываний требует больше времени чем интервал между таймерами, то они будут опаздывать.
Пользователь так-же может устанавливать таймеры со временем срабатывания в прошлом.

Опоздавшие таймеры обрабатываются в контексте основного цикла. В ядро теймеры с нулевой или
отрицательной задержкой не попадают.

##### Худшие сценарии #####

Постоянное добавление или удаление (срабатывание) самого раннего таймера.

#### Специфика драйверов ####

Для select не требуется добавления/удаления событий из ядра - всё происходит в user-space.

epoll не может вернуть из ядра одновременно дескриптор на которм произошло событие и адрес управляющей структуры для него.
Поэтому приходится иметь базовый класс который хранит дескриптор, и наследовать от него класс с управляющими данными. Для таймера это
class CanPoll (базовый, хранит timer_fd) и class Timer, наследующий от него.

#### Сигналы ####

#### Специфика драйверов ####

Драйвер select (пока) содержит стстические переменные - при использовании сигналов
возможен только один инстанс fallback event loop
